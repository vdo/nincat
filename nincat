#!/usr/bin/env bash
# nincat: A colorful, verbose bash-ish netcat using /dev/tcp

usage() {
  cat <<EOF
Usage: $0 [options] <host> <port>

Options:
  -c           Send CRLF as line-ending.
  -z           Zero-I/O mode, just scan for open ports (TCP only).
  -w <sec>     Timeout for connections.
  --no-color   Disable ANSI colors.
  -h, --help   Show this help.

Examples:
  $0 example.com 80
  $0 -c example.com 80 <<< 'GET / HTTP/1.0'
  $0 -z -w 5 example.com 22
  $0 -c whois.ripe.net 43 <<< "example.com"
EOF
}

# ---------- args ----------
COLOR=1
HOST=""
PORT=""
Z_FLAG=0
TIMEOUT=0
CRLF_FLAG=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    -c) CRLF_FLAG=1; shift ;;
    -z) Z_FLAG=1; shift ;;
    -w)
      if [[ -z "$2" || ! "$2" =~ ^[0-9]+$ ]]; then
        echo "Error: -w requires a numeric argument." >&2; exit 2
      fi
      TIMEOUT="$2"; shift 2
      ;;
    --no-color) COLOR=0; shift ;;
    -h|--help) usage; exit 0 ;;
    -*)
      echo "Unknown option: $1" >&2
      usage; exit 2
      ;;
    *)
      if [[ -z "$HOST" ]]; then HOST="$1"
      elif [[ -z "$PORT" ]]; then PORT="$1"
      else
        echo "Unexpected argument: $1" >&2; usage; exit 2
      fi
      shift
      ;;
  esac
done

if [[ -z "$HOST" || -z "$PORT" ]]; then
  usage; exit 1
fi

# ---------- colors ----------
if [[ $COLOR -eq 1 ]]; then
  BOLD=$'\e[1m'; DIM=$'\e[2m'; RESET=$'\e[0m'
  RED=$'\e[31m'; GREEN=$'\e[32m'; YELLOW=$'\e[33m'; BLUE=$'\e[34m'; MAGENTA=$'\e[35m'; CYAN=$'\e[36m'
else
  BOLD=""; DIM=""; RESET=""
  RED=""; GREEN=""; YELLOW=""; BLUE=""; MAGENTA=""; CYAN=""
fi

prefix() {
  # $1 = color, $2 = label, rest = message
  local c="$1" l="$2"; shift 2
  printf "%b[%s]%b %s\n" "$c" "$l" "$RESET" "$*"
}

hr() {
  printf "%bâ€”%b\n" "$DIM" "$RESET"
}

# ---------- connect ----------
if [[ $Z_FLAG -eq 1 ]]; then
  prefix "$CYAN" "*" "Scanning ${BOLD}${HOST}${RESET}${CYAN}:${BOLD}${PORT}${RESET}${CYAN} ..."
  cmd="(exec 3<>/dev/tcp/${HOST}/${PORT}) 2>/dev/null"
  if [[ $TIMEOUT -gt 0 ]]; then
    cmd="timeout $TIMEOUT bash -c '$cmd'"
  fi

  if eval "$cmd"; then
    prefix "$GREEN" "+" "Connection to ${HOST}:${PORT} succeeded!"
    exit 0
  else
    prefix "$RED" "!" "Connection to ${HOST}:${PORT} failed or timed out."
    exit 1
  fi
fi

prefix "$CYAN" "*" "Connecting to ${BOLD}${HOST}${RESET}${CYAN}:${BOLD}${PORT}${RESET}${CYAN} ..."

if [[ $TIMEOUT -gt 0 ]]; then
  # Use coproc to run the connection in the background with a timeout.
  coproc NC_CONN { timeout "$TIMEOUT" bash -c "exec 3<>/dev/tcp/${HOST}/${PORT}" 2>/dev/null; }

  # Wait for the coproc to finish to get the exit code.
  wait "${NC_CONN_PID}" 2>/dev/null
  exit_code=$?

  if [[ $exit_code -ne 0 ]]; then
    # 124 is the exit code for `timeout` command when it times out.
    if [[ $exit_code -eq 124 ]]; then
      prefix "$RED" "!" "Failed to connect to ${HOST}:${PORT} (timed out)"
    else
      prefix "$RED" "!" "Failed to connect to ${HOST}:${PORT}"
    fi
    exit 1
  fi

  # Redirect the coproc's file descriptor to our main script's fd 3.
  exec 3<&${NC_CONN[0]} 3>&${NC_CONN[1]}
  # Close the original coproc file descriptors.
  exec {NC_CONN[0]}<&- {NC_CONN[1]}>&-
else
  # Original behavior without timeout. Redirect stderr to /dev/null to avoid printing
  # the default "connection refused" message, as we handle it ourselves.
  (exec 3<>/dev/tcp/${HOST}/${PORT}) 2>/dev/null
  if [[ $? -ne 0 ]]; then
    prefix "$RED" "!" "Failed to connect to ${HOST}:${PORT}"
    exit 1
  fi
  exec 3<>/dev/tcp/${HOST}/${PORT}
fi

prefix "$GREEN" "+" "Connected. Press Ctrl+C to exit."
hr

# ---------- traps (match `working` style) ----------
CAT_PID=""
control_c() {
  echo
  prefix "$MAGENTA" "!" "Caught SIGINT, closing..."
  [[ -n "$CAT_PID" ]] && kill "$CAT_PID" 2>/dev/null
  exec 3<&- 3>&-
  prefix "$BLUE" "*" "Connection closed."
  exit 130
}

trap control_c SIGINT

# ---------- I/O ----------
# Background: read from socket -> stdout
cat <&3 &
CAT_PID=$!

# Foreground: stdin -> socket
if [[ $CRLF_FLAG -eq 1 ]]; then
  # In CRLF mode, we use sed to convert line endings.
  # This is not binary-safe.
  sed 's/$/\r/' >&3
else
  # Binary-safe mode: simple passthrough
  cat >&3
fi

# If remote closes, wait and exit gracefully.
wait "$CAT_PID"
prefix "$BLUE" "*" "Remote closed connection."
exec 3<&- 3>&-
exit 0